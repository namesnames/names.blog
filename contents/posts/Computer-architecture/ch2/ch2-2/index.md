---
title: "명령어의 구조 [컴퓨터 구조]"
description: "명령어의 구조 [컴퓨터 구조]"
date: 2022-07-28
update: 2023-07-28
tags:
  - 컴퓨터 구조

series: "컴퓨터 구조"
---


## 어셈블리어
>![](https://velog.velcdn.com/images/97gkswn/post/935de314-9dbd-4d53-8dbe-8145190c901b/image.png)위 사진은 어셈블리어의 예시입니다.
![](https://velog.velcdn.com/images/97gkswn/post/e580ab8e-903f-4d11-b1a8-d2b2130b59b3/image.png)
- 왼쪽의 빨간 색 글씨는 `명령어가 수행해야 할 연산`을 의미하고 `연산 코드`라고 합니다.
- 오른쪽 검은 글씨는 `연산에 사용할 데이터 or 그 데이터가 저장된 위치`를  의미하고 `오퍼랜드`라고 합니다.
-> 근데 보통은 연산에 사용할 데이터를 직접 명시하기보다는 저장된 위치, 즉 `주로 메모리 주소나 레지스터 이름이 담깁니다.` 
<br>
![](https://velog.velcdn.com/images/97gkswn/post/69ca81ef-e8de-4a30-b2b1-e097fffa8315/image.png)
- 연산 코드가 담기는 영역을 `연산 코드 필드`라고 하고 오퍼랜드가 담기는 영역을 `오퍼랜드 필드 or 주소 필드`라고 합니다.

## 연산 코드
연산 코드는 명령어가 수행할 연산을 의미한다고 했습니다.
크게 4가지 유형이 있는데요!
### 1. 데이터 전송 
- MOVE: 데이터를옮겨라

- STORE: 메모리에저장하라
- LOAD (FETCH): 메모리에서CPU로데이터를가져와라 
- PUSH: 스택에데이터를저장하라
- POP: 스택의최상단데이터를가져와라
### 2. 산술/논리연산 
- ADD / SUBTRACT/ MULTIPLY/ DIVIDE: 덧셈/ 뺄셈/ 곱셈/ 나눗셈을 수행하라
- INCREMENT/ DECREMENT: 오퍼랜드에 1을 더하라/ 오퍼랜드에 1을 빼라   

- AND/OR/NOT : AND/OR/NOT연산을 수행하라
- COMPARE : 두개의 숫자 또는 TRUE/FALSE 값을 비교하라

### 3. 제어 흐름 변경 
- JUMP: 특정주소로 실행순서를 옮겨라
- CONDITIONAL JUMP: 조건에 부합할 때 특정주소로 실행 순서를 옮겨라 
- HALT: 프로그램의 실행을 멈춰라
- CALL: 되돌아올주소를 저장한 채 특정주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라

### 4. 입출력 제어
-  READ (INPUT): 특정 입출력 장치로부터 데이터를 읽어라 
- WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
-  STARTIO: 입출력 장치를 시작하라
-  TESTIO: 입출력 장치의 상태를 확인하라

## 유효 주소
>![](https://velog.velcdn.com/images/97gkswn/post/eb812f92-6fdf-4a8a-8d45-0495073dd389/image.png)
연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소`라고 합니다.

## 주소 지정 방식
오퍼랜드 필드에 주소가 저장되어있고 그 주소에는 연산에 쓸 데이터들이 저장되어 있다고 했잖아요?
그 데이터들의 위치를 찾는 방식을 `주소 지정 방식`이라고 합니다.
다섯 가지가 있는데 하나하나 살펴보겠습니다!

### 즉시 주소 지정 방식
![](https://velog.velcdn.com/images/97gkswn/post/4ee74c2e-0d31-4718-b105-911fcaad4d85/image.png)

- 연산에 필요한 데이터들은 오퍼랜드 필드에 직접 명시하는 방법입니다.
- 속도가 빠르긴 한데 데이터 자체가 내용이 많아서 표현할 수 있는 데이터의 크기는 작은 편입니다



### 직접 주소 지정 방식
![](https://velog.velcdn.com/images/97gkswn/post/c3b140a5-249c-4c76-9453-0d897852c442/image.png)

- 오퍼랜드 필드에 유효 주소를 직접 명시하는 방법입니다.

### 간접 주소 지정 방식
![](https://velog.velcdn.com/images/97gkswn/post/ee31c1c4-3260-4b01-a166-613bb336794f/image.png)
- 연산에 사용할 데이터의 주소가 있잖아요? 그 주소를 메모리에 또 저장해놓고 그 저장해놓은 주소를 오퍼랜드 필드에 쓰는 방식입니다. 
- 이렇게하면 표현할 수 있는 유효 주소의 범위가 넓어진다고 합니다.
- 하지만 두 번의 메모리 접근 때문에 속도는 느리다고 하네요.

### 레지스터 주소 지정 방식
![](https://velog.velcdn.com/images/97gkswn/post/fd79e9e4-072b-4ef7-9c3f-ef568d553f70/image.png)

- 연산에 사용할 데이터가 레지스터에 저장되어 있는 경우입니다.
- 따라서 그 레지스터를 오퍼랜드 필드에 직접 명시하는 방법입니다.
- 메모리는 CPU외부에 있고 레지스터는 CPU내부에 있는데 CPU내부에 있는 레지스터에 접근하는 것이 더 빠르기 때문에 데이터에 빠르게 접근할 수 있습니다.
- 하지만 마찬가지로 레지스터 이름을 직접 명시하면 표현할 수 있는 레지스터 이름이 몇 개 안되겠죠? 

### 레지스터 간접 주소 지정 방식
![](https://velog.velcdn.com/images/97gkswn/post/0fb65e87-d488-4942-a7a8-ca43a2105412/image.png)

- 연산에 사용될 데이터를 메모리에 저장해두고 그 저장된 데이터의 주소를 레지스터에 저장하는 방식입니다.
- 메모리에 접근하는 횟수가 1번이라서 간접 주소 지정 방식보다 빠릅니다.

<br>

이 밖에도 다양하고 중요한 주소 지정 방식들이 존재합니다!




